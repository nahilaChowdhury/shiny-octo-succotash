
#importing libraries
from tkinter import *
import tkinter as tk
import sqlite3
import statistics
from tkinter import messagebox
import collections

conn = sqlite3.connect('database8.db') #creates the file
#conn =sqlite3.connect(':memory:') #will create a fresh database every time. Useful for testing

cur = conn.cursor() # cursor that allows you to run sql commands

cur.execute("""CREATE TABLE IF NOT EXISTS class(  

         ID INTEGER PRIMARY KEY,
         first TEXT,
         last TEXT,
         mark INTEGER,
         target_grade TEXT,
         percentage INTEGER,
         grade TEXT
         

)""") #creating table with name 'class' and fields: ID, first, last,mark,target_grade,percentage
conn.commit() #this commits the current transaction

##cur.execute ("DELETE FROM class ")
##conn.commit()






LARGE_FONT = ("Verdana", 12) # specifying the font




class baseline (tk.Tk):  #basline is inheriting .Tk() class. Give us access to widgets and stuff

    def __init__(self, *args, **kwargs): #*args - used to pass a variable number of arguments to a function
        
        tk.Tk.__init__(self, *args, **kwargs) # **kwargs - used to pass a keyworded, variable length argument list
        container = tk.Frame(self) # self represents the instances of a class - attributes and methods. Container is an object created from the pre-made class tk. and using the pre-made method .Frame

        container.pack(side = "top", fill = "both", expand = True) #describing the container . fill tells the manager tat the widget wants to fill the entire space assigned to it.

        #Expand tells the manager to assign additional space to the widget box.
        
        

        # the container is where we'll stack a bunch of frames
        # on top of each other, then the one we want visible
        # will be raised above the others

        container.grid_rowconfigure(0, weight = 1, ) #sets options for rows of cells
        container.grid_columnconfigure(0, weight = 1) #sets options for columns of cells

        self.frames = {}  #tuple

        for F in (ActualStartPage,Markbook, LookAtDatabase, InsertData,GetStudentData,UpdateMark, UpdateTargetGrade, RemoveStudent, Submit, ProceedToAnalysis, Analysis_Page):

            frame = F(container,self) #navigating through each page 

            self.frames[F] =frame
            
            frame.grid(row =0, column = 0, sticky ="nsew") #sticky does alignment +strech (north, south, east west)

        self.show_frame(ActualStartPage) #show_frame shows the starting frame

    def show_frame(self, cont): #method of the parent class
        '''raising the current page to the top'''

        frame = self.frames[cont]
        frame.tkraise() #riases the frame to the top
        frame.configure(bg ='LightSteelBlue')

        # put all of the pages in the same location;
        # the one on the top of the stacking order
        # will be the one that is visible.


class ActualStartPage (tk.Frame):  #creating another class inheriting the parent class tk.Tk

    def __init__(self, parent, controller):
        tk.Frame.__init__(self, parent)

        
        label = tk.Label(self, text = "Class Analysis", font = LARGE_FONT, bg = 'LightSteelBlue')  #title of the page
        label.grid(column = 10,row = 0, columnspan =2, pady = 10, padx = 10)


        #buttons

        edit_button = tk.Button(self, text = "Mark Book",
                            command =  lambda:controller.show_frame(Markbook))
                            
        edit_button.grid(row = 2 , column= 10,)

        proceed_button = tk.Button(self, text = "Proceed to Analysis",
                            command =  lambda:controller.show_frame(ProceedToAnalysis))
                            
        proceed_button.grid(row = 4 , column= 10, )



class Markbook(tk.Frame):

    def __init__(self, parent, controller):
        tk.Frame.__init__(self,parent)

        label = tk.Label(self,text = "Mark Book", font = LARGE_FONT, bg = 'LightSteelBlue')
        label.grid(column = 0, row = 0, columnspan = 2, pady = 10, padx =10)

        home_button = tk.Button(self, text = "Back to home",
                            command =  lambda:controller.show_frame(ActualStartPage))
                            
        home_button.grid(row = 9 , column= 1, columnspan = 2, sticky = W)

        #database button


        look_at_database_button = tk.Button(self, text = "Look at the database",
                            command =  lambda:controller.show_frame(LookAtDatabase))
                            
        look_at_database_button.grid(row = 2 , column= 1, columnspan = 2, sticky = W)

        #insert data button

        insert_data_button = tk.Button(self, text = "Insert Data",
                            command =  lambda:controller.show_frame(InsertData))
                            
        insert_data_button.grid(row = 3 , column= 1, columnspan = 2, sticky = W)

        #get student data button

        get_student_data_button = tk.Button(self, text = "Get Student Data",
                            command =  lambda:controller.show_frame(GetStudentData))
                            
        get_student_data_button.grid(row = 4 , column= 1, columnspan = 2,sticky = W)


        #update mark

        update_mark_button = tk.Button(self, text = "Update Mark",
                            command =  lambda:controller.show_frame(UpdateMark))
                            
        update_mark_button.grid(row = 5 , column= 1, columnspan = 2,sticky = W)

        


        #update target grade

        update_target_grade_button = tk.Button(self, text = "Update Target Grade",
                            command =  lambda:controller.show_frame(UpdateTargetGrade))
                            
        update_target_grade_button.grid(row = 6 , column= 1, columnspan = 2,sticky = W)


        #remove student

        remove_student_button = tk.Button(self, text = "Remove Student",
                                          command = lambda: controller.show_frame(RemoveStudent))
        remove_student_button.grid(row = 7, column =1 , columnspan = 2,sticky = W)

        #delete entire class
        delete_button = tk.Button(self,text = "Delete Class",
                                  command = self.delete_class)
        delete_button.grid(row =8, column = 1, columnspan =2, sticky = W)


    def delete_class(self):
        cur.execute ("DELETE FROM class ")
        conn.commit()

        messagebox.showinfo("Delete class", "Class has been deleted")
            
            
        

        

class LookAtDatabase (tk.Frame):
     def __init__(self, parent, controller):
        tk.Frame.__init__(self, parent)  # parent is the main class, i.e. basline

        label = tk.Label(self, text = "Database", font = LARGE_FONT, bg = 'LightSteelBlue')
        label.grid(column = 0,row = 0 ,columnspan = 2, pady = 10, padx = 10)

        home_button = tk.Button(self, text = "Back to home",
                            command =  lambda:controller.show_frame(ActualStartPage))
                            
        home_button.grid(row = 8 , column= 1,)

        back_button = tk.Button(self, text = "Go Back",
                            command = lambda: controller.show_frame(Markbook))
        back_button.grid(row = 8, column = 0, )

        #entering the database


        print_records = ''

        cur.execute("SELECT * FROM class") 
        students = cur.fetchall()

        for records in students:
            print_records += str(records) + "\n"


        text1 = tk.Text(self, height = 15, width = 70,bg = 'gray95'  ) #adding textbox frame

        text1.insert(tk.INSERT,print_records) #insert text inside textbox frame
        text1.grid(column = 0, row = 2, columnspan =2, pady = 10, padx = 10)

        




class InsertData(tk.Frame): #method within the sub-class

    def __init__(self, parent, controller):
        tk.Frame.__init__(self, parent)  # parent is the main class, i.e. basline

        label = tk.Label(self, text = "Mark Analysis", font = LARGE_FONT, bg = 'LightSteelBlue')
        label.grid(column = 0,row = 0 ,columnspan = 2, pady = 10, padx = 10)

        #place the labels
        Label(self, text = "First Name: ", bg = 'LightSteelBlue').grid(row =1, column = 0, padx = 10, pady =5)


        Label(self, text = "Last Name: ",bg = 'LightSteelBlue').grid(row =2, column = 0, padx = 10, pady =5)

        Label(self, text = "Mark: ",bg = 'LightSteelBlue').grid(row =3, column = 0, padx = 10, pady =5)


        Label(self, text = "Target Grade: ",bg = 'LightSteelBlue').grid(row =4, column = 0, padx = 10, pady =5)



        #place the text entry fields
        


        self.firstname = Entry(self, width = 15, bg = "white")
        self.firstname.grid(row = 1, column=1, padx =5, pady = 5)

        self.lastname = Entry(self, width = 15, bg = "white")
        self.lastname.grid(row = 2, column=1, padx =5, pady = 5)

        self.mark__ = Entry(self, width = 15, bg = "white")
        self.mark__.grid(row = 3, column=1, padx =5, pady = 5)

        self.targetgrade = Entry(self, width = 15, bg = "white")
        self.targetgrade.grid(row = 4, column=1, padx =5, pady = 5)



        #Buttons to navigate


        
        button1 = tk.Button(self, text = "Submit",
                            command =  self.insertintosql)
                            
        button1.grid(row = 2 , column= 3)



        button2 = tk.Button(self, text = "Proceed",
                            command = lambda:controller.show_frame(ProceedToAnalysis) )
        button2.grid(row = 2, column = 4)

        home_button = tk.Button(self, text = "Back to home",
                            command =  lambda:controller.show_frame(ActualStartPage))
                            
        home_button.grid(row = 8 , column= 1, )

        back_button = tk.Button(self, text = "Go Back",
                            command = lambda: controller.show_frame(Markbook))
        back_button.grid(row = 8, column = 0, )


    #creating a function that inserts into database

        
    
    def insertintosql(self):
        '''inserting into database'''


        first = self.firstname.get().title()
        last= self.lastname.get().title()
        mark = self.mark__.get()
        target_grade = self.targetgrade.get().upper()
        percentage =0
        grade = "Not yet declared"

        

        #print(target_grade)
        #print(first)


        #checking to see if the error boxes have the correct format

        first_check = False
        last_check = False
        mark_check = False
        target_grade_check = False
        


        if first =="" or first.isalpha() != True or last =="" or last.isalpha() != True:
            messagebox.showerror("Error", "Please enter valid data with no special characters")
        else:
            first_check = True
            last_check = True
            


        if mark.isdigit() != True: 
            messagebox.showerror ("Error", "Please enter a valid number")
        else:

            mark_check = True

        if target_grade == "A*" or target_grade == "A" or target_grade == "B" or target_grade == "C" or target_grade == "D" or target_grade == "E":

            target_grade_check = True
            
        else:
            messagebox.showerror ("Error", "Please enter a valid grade")




 
  
 
        ##calling the function

        if first_check == True and last_check == True and mark_check == True and target_grade_check == True:
            cur.execute("INSERT INTO class (first, last, mark, target_grade, percentage,grade) VALUES (?,?,?,?,?,?)",(first,last,mark,target_grade,percentage,grade))
            conn.commit() #inserting the values in the database
            messagebox.showinfo("Insert data", "Entry Submitted")


        self.firstname.delete(0,END) # clearing the entry after the user has inputted data
        self.lastname.delete(0,END)
        self.mark__.delete(0,END)
        self.targetgrade.delete(0,END)
        self.firstname.focus_set()


class GetStudentData(tk.Frame):
    def __init__(self,parent, controller):
        tk.Frame.__init__(self, parent)  # parent is the main class, i.e. basline

        label = tk.Label(self, text = "Student Data", font = LARGE_FONT, bg = 'LightSteelBlue')
        label.grid(column = 0,row = 0 ,columnspan = 2, pady = 10, padx = 10)



        #place the labels
        Label(self, text = "First Name: ",bg = 'LightSteelBlue').grid(row =1, column = 0, padx = 10, pady =5)


        Label(self, text = "Last Name: ",bg = 'LightSteelBlue').grid(row =2, column = 0, padx = 10, pady =5)


        #placing entry widgets

        self.firstname = Entry(self, width = 15, bg = "white")
        self.firstname.grid(row = 1, column=1, padx =5, pady = 5)

        self.lastname = Entry(self, width = 15, bg = "white")
        self.lastname.grid(row = 2, column=1, padx =5, pady = 5)


        #buttons

        find_button = tk.Button(self, text = "Find",
                                command = self.get_students_by_name)
        find_button.grid(row = 1, column = 2, rowspan = 2)

        home_button = tk.Button(self, text = "Back to home",
                            command =  lambda:controller.show_frame(ActualStartPage))
                            
        home_button.grid(row = 9 , column= 1)

        back_button = tk.Button(self, text = "Go Back",
                            command = lambda: controller.show_frame(Markbook))
        back_button.grid(row = 9, column = 0, )







    def get_students_by_name(self):#function to retrieve student
        with conn:
            
            check = True
            if check == True:
            
                    first = self.firstname.get().title()
                    last = self.lastname.get().title()

                    #print(first,last)

                    cur = conn.cursor() 
                    cur.execute("SELECT * FROM class")
                    rows = cur.fetchall()


                    list_of_first_names = []
                    list_of_last_names = []

                    for i in rows:
                        list_of_first_names.append(i[1])
                        list_of_last_names.append(i[2])


                    if first in list_of_first_names and last in list_of_last_names:
                        cur.execute('SELECT * FROM class WHERE last = :last AND first =:first',{'last':last, 'first': first})
                        student_data = cur.fetchall()



                        for i in student_data:
                            first =(i[1])
                            last =(i[2])
                            mark =(i[3])
                            target_grade=(i[4])
                            percentage =(i[5])
                            grade=(i[6])

                        messagebox.showinfo("Student Data", ("Name: ",first,last ,"\n","Mark: ",mark,"\n", "Target Grade: ", target_grade,"\n", "Percentage: ",percentage,"\n", "Grade: ", grade) )
                        self.firstname.delete(0,END)
                        self.lastname.delete(0,END)


##                        text1 = tk.Text(self, height = 15, width = 70, bg = 'gray95' ) #adding textbox frame
##
##                        text1.insert(tk.INSERT,(first,",",last,",",mark,",",target_grade,",",percentage,"%",",",grade)) #insert text inside textbox frame
##                        text1.grid(column = 0, row = 2, columnspan =2, pady = 10, padx = 10)


                        
                        check = False

                    else:
                        messagebox.showerror("Error", "Name not recognised")
                        #self.firstname.delete(0,END) # clearing the entry after the user has inputted data
                        #self.lastname.delete(0,END) 
                    check = True

            else:
                pass




            #4: When you press the get strudent function again it goes straight to the textbox

            



class UpdateMark(tk.Frame):
    def __init__(self, parent, controller):
        tk.Frame.__init__(self, parent)  # parent is the main class, i.e. basline

        label = tk.Label(self, text = "Update Student's Mark", font = LARGE_FONT, bg = 'LightSteelBlue')
        label.grid(column = 0,row = 0 ,columnspan = 2, pady = 10, padx = 10)




        #place the labels
        Label(self, text = "First Name: ",bg = 'LightSteelBlue').grid(row =1, column = 0, padx = 10, pady =5)


        Label(self, text = "Last Name: ",bg = 'LightSteelBlue').grid(row =2, column = 0, padx = 10, pady =5)

        Label(self, text = "New Mark: ",bg = 'LightSteelBlue').grid(row =3, column = 0, padx = 10, pady =5)
        


        #placing entry widgets

        self.firstname = Entry(self, width = 15, bg = "white")
        self.firstname.grid(row = 1, column=1, padx =5, pady = 5)

        self.lastname = Entry(self, width = 15, bg = "white")
        self.lastname.grid(row = 2, column=1, padx =5, pady = 5)

        self.new_mark = Entry(self, width = 15, bg = "white")
        self.new_mark.grid(row = 3, column=1, padx =5, pady = 5)


        




        #buttons

        home_button = tk.Button(self, text = "Back to home",
                            command =  lambda:controller.show_frame(ActualStartPage))
                            
        home_button.grid(row = 8 , column= 1, )

        back_button = tk.Button(self, text = "Go Back",
                            command = lambda: controller.show_frame(Markbook))
        back_button.grid(row = 8, column = 0, )

        update_button = tk.Button(self, text = "Update",
                                command = self.update_mark)
        update_button.grid(row = 1, column = 2, rowspan =2)




    def update_mark(self): #function to update mark

        check = True
        if check == True:
        
            with conn:
                first = self.firstname.get().title()
                last = self.lastname.get().title()

                #print(first,last)

                cur = conn.cursor() 
                cur.execute("SELECT * FROM class")
                rows = cur.fetchall()


                list_of_first_names = []
                list_of_last_names = []

                for i in rows:
                    list_of_first_names.append(i[1])
                    list_of_last_names.append(i[2])

                #print(list_of_first_names)
                #print(list_of_last_names)

                if first in list_of_first_names and last in list_of_last_names:
                    mark = self.new_mark.get().title()
                    cur.execute(""" UPDATE class SET mark = :mark
                    WHERE first = :first AND last = :last""",
                    {'first': first, 'last': last, 'mark' : mark})
                    messagebox.showinfo("Mark","Record Updated")
                    check = False

                else:
                    messagebox.showerror("Error", "Name not recognised")
                    check = True

                    

        else:
            pass


                    
                

            


            

    

class UpdateTargetGrade(tk.Frame):
    def __init__(self, parent, controller):
        tk.Frame.__init__(self, parent)  # parent is the main class, i.e. basline

        label = tk.Label(self, text = "Update Student's Target Grade", font = LARGE_FONT,bg = 'LightSteelBlue')
        label.grid(column = 0,row = 0 ,columnspan = 2, pady = 10, padx = 10)




        #buttons

        home_button = tk.Button(self, text = "Back to home",
                            command =  lambda:controller.show_frame(ActualStartPage))
                            
        home_button.grid(row = 8 , column= 1, columnspan = 2)

        back_button = tk.Button(self, text = "Go Back",
                            command = lambda: controller.show_frame(Markbook))
        back_button.grid(row = 8, column = 0, columnspan = 2)

        update_button = tk.Button(self, text = "Update",
                                command = self.update_target_grade)
        update_button.grid(row = 1, column = 2, rowspan = 2)

        


     #place the labels
        Label(self, text = "First Name: ",bg = 'LightSteelBlue').grid(row =1, column = 0, padx = 10, pady =5)


        Label(self, text = "Last Name: ",bg = 'LightSteelBlue').grid(row =2, column = 0, padx = 10, pady =5)

        Label(self, text = "New Target Grade: ",bg = 'LightSteelBlue').grid(row =3, column = 0, padx = 10, pady =5)
        


        #placing entry widgets

        self.firstname = Entry(self, width = 15, bg = "white")
        self.firstname.grid(row = 1, column=1, padx =5, pady = 5)

        self.lastname = Entry(self, width = 15, bg = "white")
        self.lastname.grid(row = 2, column=1, padx =5, pady = 5)

        self.new_target_grade = Entry(self, width = 15, bg = "white")
        self.new_target_grade.grid(row = 3, column=1, padx =5, pady = 5)


    def update_target_grade(self): #function to update target grade
        with conn:

            check = True
            if check == True:
        
        
                first = self.firstname.get().title()
                last = self.lastname.get().title()
                #target_grade = self.new_target_grade.get().title()

                #print(first,last)

                cur = conn.cursor() 
                cur.execute("SELECT * FROM class")
                rows = cur.fetchall()


                list_of_first_names = []
                list_of_last_names = []

                for i in rows:
                    list_of_first_names.append(i[1])
                    list_of_last_names.append(i[2])

                #print(list_of_first_names)
                #print(list_of_last_names)

                if first in list_of_first_names and last in list_of_last_names:
                    target_grade = self.new_target_grade.get().title()
                    cur.execute(""" UPDATE class SET target_grade = :target_grade
                                WHERE first = :first AND last = :last""",
                                {'first':first, 'last':last, 'target_grade' : target_grade})

                    messagebox.showinfo("Target Grade", "Record updated")

                    check = False

                else:
                    messagebox.showerror("Error", "Name not recognised")
                    check = True

                    

            else:
                pass



class RemoveStudent(tk.Frame):
     def __init__(self, parent, controller):
        tk.Frame.__init__(self, parent)  # parent is the main class, i.e. basline

        label = tk.Label(self, text = "Remove Student", font = LARGE_FONT,bg = 'LightSteelBlue')
        label.grid(column = 0,row = 0 ,columnspan = 2, pady = 10, padx = 10)


        #place the labels
        Label(self, text = "First Name: ",bg = 'LightSteelBlue').grid(row =1, column = 0, padx = 10, pady =5)


        Label(self, text = "Last Name: ",bg = 'LightSteelBlue').grid(row =2, column = 0, padx = 10, pady =5)

        


        #placing entry widgets

        self.firstname = Entry(self, width = 15, bg = "white")
        self.firstname.grid(row = 1, column=1, padx =5, pady = 5)

        self.lastname = Entry(self, width = 15, bg = "white")
        self.lastname.grid(row = 2, column=1, padx =5, pady = 5)


        #buttons

        home_button = tk.Button(self, text = "Back to home",
                            command =  lambda:controller.show_frame(ActualStartPage))
                            
        home_button.grid(row = 8 , column= 1,)

        back_button = tk.Button(self, text = "Go Back",
                            command = lambda: controller.show_frame(Markbook))
        back_button.grid(row = 8, column = 0, )

        remove_button = tk.Button(self, text = "Remove Student",
                                command = self.remove_student)
        remove_button.grid(row = 1, column = 2, rowspan =2)


     def remove_student (self): #function to remove student
        with conn:
            first = self.firstname.get().title()
            last = self.lastname.get().title()
            cur.execute("DELETE from class WHERE first = :first AND last = :last",
                      {'first':first, 'last':last})

            messagebox.showinfo("Remove Student", "Record Updated")



           
        

class Submit(tk.Frame):

    def __init__(self, parent, controller):
        tk.Frame.__init__(self,parent)
        label = tk.Label(self, text = "Entry Submitted", font = LARGE_FONT)
        label.grid(pady = 10, padx = 10)

        button1 = tk.Button(self, text = "Back to Home",
                            command = lambda:controller.show_frame(StartPage) )
        button1.grid(row = 8 , column= 0)

        button2 = tk.Button(self, text = "Proceed",
                            command = lambda:controller.show_frame(ProceedToAnalysis) )
        button2.grid(row = 8, column = 3)

        back_button = tk.Button(self, text = "Go Back",
                            command = lambda: controller.show_frame(Markbook))
        back_button.grid(row = 8, column = 1, columnspan = 2)

        

class ProceedToAnalysis(tk.Frame):





    def __init__(self, parent, controller):
        tk.Frame.__init__(self,parent)
        label = tk.Label(self, text = "Analysis", font = LARGE_FONT, bg = 'LightSteelBlue') 
        label.grid(pady = 10, padx = 10)

    



        #buttons

        button1 = tk.Button(self, text = "Back to Home",
                            command = lambda:controller.show_frame(ActualStartPage) )
        button1.grid(row = 4 , column= 0, columnspan =2)
        
        def on_enter_button():
         self.validate_total_mark
         controller.show_frame(Analysis_Page)

        enter_button = tk.Button(self, text = "Enter",
                                 command = on_enter_button)

       
        enter_button.grid(row = 1, column = 3)


##        next_button = tk.Button(self, text = "Next",
##                                command = lambda:controller.show_frame(Analysis_Page))
##        next_button.grid(row = 3, column = 3)

        jump_button = tk.Button(self,text ="Current Analysis",
                                command = self.actual_analysis_2)

        jump_button.grid(row = 4, column =3)


            
        cur.execute("SELECT (mark) FROM class")
        result = cur.fetchall()


        global list_of_marks
        list_of_marks = [] #the students mark in a list
        
        
      
        for i in result:
                
                list_of_marks.append(i[0])

        count = len(list_of_marks)
        #print("list_of_marks: ", list_of_marks)

        list_of_marks.sort() #sorting the list of marks in alphabetical order
        #print(a)




        #place the labels
        Label(self, text = "Total Mark: ",bg = 'LightSteelBlue').grid(row =1, column = 0, padx = 10, pady =5)

        #place entry widgets


        self.total_mark = Entry(self, width = 15, bg = "white")
        self.total_mark.grid(row = 1, column=1, padx =5, pady = 5)

       

        

    def actual_analysis_2(self):
        count = len(list_of_marks)
            

        avg_mark = round(sum(list_of_marks)/count,1)  #calculating the average mark
        #print("Avergage mark: ", avg_mark)

        avg_percentage = round(sum(list_of_marks)/count,1) #calculating the average percentage
        
        #print("Average percentage: ",avg_percentage,"%" )

        #median

        def Median (list_of_marks):  
            _len = list_of_marks.sort()
            _len = len(list_of_marks)
            median = 0
            if _len% 2 == 0:
                median = float((list_of_marks[(_len //2) -1] + list_of_marks[(_len // 2 )])/2) #index starts from 0.
                #print("Median: ",median)
                return median

            else:
                median = list_of_marks[_len//2]
                #print("Median: ",median)
                return median
        #Median(list_of_marks)


        mode = max(set(list_of_marks), key=list_of_marks.count)
        #print("Mode: ",mode)

        #range

        range_val = max(list_of_marks) - min(list_of_marks)
        #print("Range: ",range_val)


        #standard deviation

        sd= round(statistics.stdev(list_of_marks),1)
        #print(sd)

        
        #new_line = "\n" 



        messagebox.showinfo("Analysis", ("Average Mark: ",avg_mark,"\n", "Average Percentage: ", avg_percentage,"%","\n", "Median: ", Median(list_of_marks), "\n",  "Mode: ", mode, "\n", "Range: ", range_val, "\n", "Standard Deviation: ", sd))

    def validate_total_mark(self):
        print("Does total_mark work?")
        global total_mark
        total_mark = self.total_mark.get()
        
        #print(isinstance(total_mark, str))

        check = True
        if check == True:
               
        

                if total_mark == '':
                    messagebox.showerror('Error', 'Please enter a value')
                    self.total_mark.get()
                    check = True

                else:

                    check = True
                    if check == True:

                        if total_mark.isdigit() != True:
                            messagebox.showerror ("Error", "Please enter an integer")
                            self.total_mark.get()
                            check = True

                        else:
                            
                            max_mark = list_of_marks[-1]
                            #print("This is the max mark: ", max_mark)
                            #print(isinstance(total_mark, str))

                            total_mark = int(total_mark)
                            
                            if total_mark < max_mark:
                                    messagebox.showerror("Error", "Total Mark cannot be lower than a student's grade.")
                                    self.total_mark.get()
                                    check = True

                            else:
                                self.percentage()
                                lambda:controller.show_frame(ProceedToAnalysis)
                                print("This has worked")



    def  percentage(self):

        global list_of_marks
        global total_mark

        total_mark = self.total_mark.get()
        
        #print(isinstance(total_mark, str))

        check = True
        if check == True:

                if total_mark == '':
                    messagebox.showerror('Error', 'Please enter a value')
                    self.total_mark.get()
                    check = True

                else:

                    check = True
                    if check == True:

                        if total_mark.isdigit() != True:
                            messagebox.showerror ("Error", "Please enter an integer")
                            self.total_mark.get()
                            check = True

                        else:
                            
                            max_mark = list_of_marks[-1]
                            #print("This is the max mark: ", max_mark)
                            #print(isinstance(total_mark, str))

                            total_mark = int(total_mark)
                            
                            if total_mark < max_mark:
                                    messagebox.showerror("Error", "Total Mark cannot be lower than a student's grade.")
                                    self.total_mark.get()
                                    check = True
                            else:
                                

                                    #total_mark = int(self.total_mark.get())
                                    #print(total_mark)

                                    cur = conn.cursor() 
                                    cur.execute("SELECT * FROM class")
                                    rows = cur.fetchall()
                                    #print ("This is rows: ", rows)


                                    
                                    global another_list_of_marks
                                    

                                    list_of_marks= []  # list of marks
                                    for i in rows:  #changing the marks into a perentage value then appending it to a list
                                            mark = (i[3])
                                            percentage = round(((mark/total_mark)*100),1)
                                            list_of_marks.append(percentage)
                                            #print("This is the percentage", percentage)
                                    #print(b) #list of raw marks

                                    #print(list_of_marks)

                                    

                                    for i, val in enumerate(list_of_marks): #goes through each primary key and updates the percentage field
                                            #print("UPDATE class SET percentage = (?) WHERE ID = (?)",(val,(i+1),))
                                            cur.execute("UPDATE class SET percentage = (?) WHERE ID = (?)",(val,(i+1),))
                                    conn.commit()

    def multiple_functions(self, *args):  
        for argument in args:
            args

   
                                    



class Analysis_Page(tk.Frame):
    def __init__(self, parent, controller):
        
        tk.Frame.__init__(self,parent)
        label = tk.Label(self, text = "Analysis of the Class", font = LARGE_FONT,bg = 'LightSteelBlue')
        label.grid(pady = 10, padx = 10)

        next_button = tk.Button(self, text = "Next",
                                command = self.enter_grade)
        next_button.grid(row = 3, column = 3)

        
        button1 = tk.Button(self, text = "Back to Home",
                            command = lambda:controller.show_frame(ActualStartPage) )
        button1.grid(row = 7 , column= 1, columnspan =2)




        

        Label(self, text = "A* ",bg = 'LightSteelBlue').grid(row =1, column = 0, padx = 10, pady =5)
        Label(self, text = "A ",bg = 'LightSteelBlue').grid(row =2, column = 0, padx = 10, pady =5)
        Label(self, text = "B ",bg = 'LightSteelBlue').grid(row =3, column = 0, padx = 10, pady =5)
        Label(self, text = "C",bg = 'LightSteelBlue').grid(row =4, column = 0, padx = 10, pady =5)
        Label(self, text = "D ",bg = 'LightSteelBlue').grid(row =5, column = 0, padx = 10, pady =5)
        Label(self, text = "E ",bg = 'LightSteelBlue').grid(row =6, column = 0, padx = 10, pady =5)
       
        



        self.a_star = Entry(self, width = 15, bg = "white")
        self.a_star.grid(row = 1, column = 1, padx= 5, pady=5)

        self.a = Entry(self, width = 15, bg = "white")
        self.a.grid(row = 2, column = 1, padx= 5, pady=5)

        self.b = Entry(self, width = 15, bg = "white")
        self.b.grid(row = 3, column = 1, padx= 5, pady=5)

        self.c = Entry(self, width = 15, bg = "white")
        self.c.grid(row = 4, column = 1, padx= 5, pady=5)

        self.d = Entry(self, width = 15, bg = "white")
        self.d.grid(row = 5, column = 1, padx= 5, pady=5)

        self.e = Entry(self, width = 15, bg = "white")
        self.e.grid(row = 6, column = 1, padx= 5, pady=5)

        


    def enter_grade(self):
        a_star = self.a_star.get()
        a = self.a.get()
        b = self.b.get()
        c= self.c.get()
        d = self.d.get()
        e= self.e.get()

        global total_mark

       #print(isinstance(a_star, str)) #--> True
       # print(isinstance(a_star_int,str )) #--> False

       

        check = True
        if check == True:

                if a_star == '':
                    messagebox.showerror("Error", "Please enter value for A*")
                    self.a_star.get()
                    check = True

                else:
                    
                    if a_star.isdigit() != True:
                        messagebox.showerror("Error", "A* is not an integer")
                        self.a_star.get()
                        check = True

                    else:
                        a_star_int = int(a_star)
                        if a_star_int > total_mark:
                            messagebox.showerror("Error", "Grade boundaries cannot be greater than the total mark for the test")
                            self.a_star.get()
                            check = True
                        else:
                            
                            check = True
                            if check == True:

                                    if a == '':
                                        messagebox.showerror("Error", "Please enter value for A")
                                        self.a.get()
                                        check = True

                                    else:
                                        if a.isdigit() != True:
                                            messagebox.showerror("Error", "A is not an integer")
                                            self.a.get()
                                            check = True

                                        else:
                                            a_int = int(a)
                                            if a_int > total_mark:
                                                messagebox.showerror("Error", "Grade boundaries cannot be greater than the total mark for the test")
                                                self.a.get()
                                                check = True
                                            else:
                                                check = True
                                                if check == True:

                                                        if b == '':
                                                            messagebox.showerror("Error", "Please enter value for B")
                                                            self.b.get()
                                                            check = True

                                                        else:
                                                            if b.isdigit() != True:
                                                                messagebox.showerror("Error", "B is not an integer")
                                                                self.b.get()
                                                                check = True

                                                            else:
                                                                b_int = int(b)
                                                                if b_int > total_mark:
                                                                    messagebox.showerror("Error", "Grade boundaries cannot be greater than the total mark for the test")
                                                                    self.b.get()
                                                                    check = True
                                                                else:
                                                                    check = True
                                                                    if check == True:

                                                                            if c == '':
                                                                                messagebox.showerror("Error", "Please enter value for C")
                                                                                self.c.get()
                                                                                check = True

                                                                            else:
                                                                                if c.isdigit() != True:
                                                                                    messagebox.showerror("Error", "C is not an integer")
                                                                                    self.c.get()
                                                                                    check = True

                                                                                else:
                                                                                    c_int = int(c)
                                                                                    if c_int > total_mark:
                                                                                        messagebox.showerror("Error", "Grade boundaries cannot be greater than the total mark for the test")
                                                                                        self.c.get()
                                                                                        check = True
                                                                                    else:
                                                                                        check = True
                                                                                        if check == True:

                                                                                                if d == '':
                                                                                                    messagebox.showerror("Error", "Please enter value for D")
                                                                                                    self.d.get()
                                                                                                    check = True

                                                                                                else:
                                                                                                    if d.isdigit() != True:
                                                                                                        messagebox.showerror("Error", "D is not an integer")
                                                                                                        self.d.get()
                                                                                                        check = True

                                                                                                    else:
                                                                                                        d_int = int(d)
                                                                                                        if d_int > total_mark:
                                                                                                            messagebox.showerror("Error", "Grade boundaries cannot be greater than the total mark for the test")
                                                                                                            self.d.get()
                                                                                                            check = True
                                                                                                        else:
                                                                                                            check = True
                                                                                                            if check == True:

                                                                                                                    if e == '':
                                                                                                                        messagebox.showerror("Error", "Please enter value for E")
                                                                                                                        self.e.get()
                                                                                                                        check = True

                                                                                                                    else:
                                                                                                                        if e.isdigit() != True:
                                                                                                                            messagebox.showerror("Error", "E is not an integer")
                                                                                                                            self.e.get()
                                                                                                                            check = True

                                                                                                                        else:
                                                                                                                            e_int = int(e)
                                                                                                                            if e_int > total_mark:
                                                                                                                                messagebox.showerror("Error", "Grade boundaries cannot be greater than the total mark for the test")
                                                                                                                                self.e.get()
                                                                                                                                check = True
                                                                                                                            else:
                                                                                                                                ##sql case statement: if mark is not within the grade parameters, do one thing, if not do the other thing
                                                                                                                                   
                                                                                                                                        sql = '''UPDATE class   
                                                                                                                                                     SET grade = CASE 
                                                                                                                                                                     WHEN mark >= :a_star_prm THEN 'A*'
                                                                                                                                                                     WHEN mark >= :a_prm AND mark < :a_star_prm THEN 'A'
                                                                                                                                                                     WHEN mark >= :b_prm AND mark < :a_prm THEN 'B'
                                                                                                                                                                     WHEN mark >= :c_prm AND mark < :b_prm THEN 'C'
                                                                                                                                                                     WHEN mark >= :d_prm AND mark < :c_prm THEN 'D'
                                                                                                                                                                     ELSE 'E'
                                                                                                                                                                   END;
                                                                                                                                                  '''
                                                                                                                                        cur.execute(sql, {'a_star_prm':a_star, 'a_prm':a, 'b_prm':b, 'c_prm':c, 'd_prm':d})
                                                                                                                                        conn.commit()

                                                                                                                                        messagebox.showinfo("Success","The table has been updated")
                                                                                                                                    #else:
                                                                                                                                        

                                                                                                                                        ###analysis:
                                                                                                                                    #def actual_analysis_1(self):
                                                                                                                                        count = len(list_of_marks)
                                                                                                                                            

                                                                                                                                        avg_mark = round(sum(list_of_marks)/count,1)  #calculating the average mark
                                                                                                                                        #print("Avergage mark: ", avg_mark)

                                                                                                                                        avg_percentage = round(sum(list_of_marks)/count,1) #calculating the average percentage
                                                                                                                                        
                                                                                                                                        #print("Average percentage: ",avg_percentage,"%" )

                                                                                                                                        #median

                                                                                                                                        def Median (list_of_marks):  
                                                                                                                                            _len = list_of_marks.sort()
                                                                                                                                            _len = len(list_of_marks)
                                                                                                                                            median = 0
                                                                                                                                            if _len% 2 == 0:
                                                                                                                                                median = float((list_of_marks[(_len //2) -1] + list_of_marks[(_len // 2 )])/2) #index starts from 0.
                                                                                                                                                #print("Median: ",median)
                                                                                                                                                return median

                                                                                                                                            else:
                                                                                                                                                median = list_of_marks[_len//2]
                                                                                                                                                #print("Median: ",median)
                                                                                                                                                return median
                                                                                                                                        #Median(list_of_marks)


##                                                                                                                                        #mode
##
##                                                                                                                                        ### calculate the frequency of each item
##
##                                                                                                                                        data = collections.Counter(list_of_marks)  #elements are stored as dictionary keys, and their count as dict values
##                                                                                                                                        data_list = dict(data) #dict() creates a dictionary
##
##                                                                                                                                        ### highest frequncy
##
##                                                                                                                                        max_value = max(list(data.values())) #returns the values of the dictionary as a list
##                                                                                                                                        mode_val = [num for num, freq in data_list.items() if freq == max_value]
##                                                                                                                                        if len(mode_val) == len(list_of_marks):
##                                                                                                                                            mode = "No mode in the list"
##                                                                                                                                            return mode
##
##                                                                                                                                        else:
##                                                                                                                                            mode = mode_val
##                                                                                                                                            return mode
##
##                                                                                                                                        print("This is the mode: ", mode)
##

                                                                                                                                        mode = max(set(list_of_marks), key=list_of_marks.count)
                                                                                                                                        #print("Mode: ",mode)

                                                                                                                                        #range

                                                                                                                                        range_val = max(list_of_marks) - min(list_of_marks)
                                                                                                                                        #print("Range: ",range_val)


                                                                                                                                        #standard deviation

                                                                                                                                        sd= round(statistics.stdev(list_of_marks),1)
                                                                                                                                        #print(sd)

                                                                                                                                        #analysis = "Average Mark:", avg_mark ,'\n' "Average Percentage: ", avg_percentage,'\n', "Median: ", Median(list_of_marks), "\n",  "Mode: ", mode, "\n", "Range: ", range_val, "\n", "Standard Deviation", sd
                                                                                                                                        #print(analysis)

                                                                                                                                        #new_line = "\n" 



                                                                                                                                        messagebox.showinfo("Analysis", ("Average Mark: ",avg_mark,"\n", "Average Percentage: ", avg_percentage,"%","\n", "Median: ", Median(list_of_marks), "\n",  "Mode: ", mode, "\n", "Range: ", range_val, "\n", "Standard Deviation: ", sd))

                                                                                                                                
                                                
  
app = baseline()
app.mainloop()


    


